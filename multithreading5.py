#!/usr/bin/env python
# ------------------------------------------------------------------------------------------------------%
# Created by "Thieu" at 10:02, 18/10/2021                                                               %
#                                                                                                       %
#       Email:      nguyenthieu2102@gmail.com                                                           %
#       Homepage:   https://www.researchgate.net/profile/Nguyen_Thieu2                                  %
#       Github:     https://github.com/thieu1995                                                        %
# ------------------------------------------------------------------------------------------------------%

import time
import concurrent.futures  # Simple and easy way to use multithreading (not handy craft)

start = time.perf_counter()


def do_something(seconds):
    print(f"Sleeping {seconds} second(s)....")
    time.sleep(seconds)
    return f"Done sleeping...{seconds} second(s)"


# Use futures better with context block to avoid error which can happen
with concurrent.futures.ThreadPoolExecutor() as executor:
    list_executors = [executor.submit(do_something, 1.5) for _ in range(20)]

    # This method yield the result everytime a thread finished their job.
    for f in concurrent.futures.as_completed(list_executors):
        print(f.result())


# with concurrent.futures.ThreadPoolExecutor() as executor:
#     secs = [2, 6, 1, 4, 3]
#     list_executors = [executor.submit(do_something, sec) for sec in secs]
#
#     # This method yield the result everytime a thread finished their job.
#     for f in concurrent.futures.as_completed(list_executors):
#         print(f.result())


## ==> Submit method done by order,
# ==> But result method will get the result of the fastest thread.
# ==> To get the result by order, (the total time is still the same because of the max time generated by thread)
# ==> we will use map function.


# with concurrent.futures.ThreadPoolExecutor() as executor:
#     secs = [2, 6, 1, 4, 3]
#     list_results = executor.map(do_something, secs)         # Return result not the future object
#
#     for result in list_results:
#         print(result)
    # Even when we comment this, it will still waiting for threadpool completed then moving to next line of code below.

finish = time.perf_counter()

print(f"Finished in {round(finish - start, 2)} second(s)")